Script started on Tue 25 Feb 2014 02:07:00 PM CST
[?1034hbash-4.2$ ls -ltr
total 76
-rw-r--r-- 1 sridhav sridhav   319 Feb 22 23:04 test_job.txt
-rw-r--r-- 1 sridhav sridhav  2183 Feb 24 11:18 Loader.java
-rw-r--r-- 1 sridhav sridhav   117 Feb 24 22:30 my_job.txt
-rw-r--r-- 1 sridhav sridhav  2598 Feb 24 23:48 Stack.java
-rw-r--r-- 1 sridhav sridhav  1036 Feb 25 00:04 Memory.java
-rw-r--r-- 1 sridhav sridhav  1869 Feb 25 00:58 System2.java
drwxr-xr-x 2 sridhav sridhav  4096 Feb 25 01:00 test_files
drwxr-xr-x 2 sridhav sridhav  4096 Feb 25 10:34 assmcode
-rw-r--r-- 1 sridhav sridhav  6484 Feb 25 10:55 Variables.java
-rw-r--r-- 1 sridhav sridhav  5192 Feb 25 10:56 ErrorHandler.java
-rw-r--r-- 1 sridhav sridhav 16584 Feb 25 11:28 CPU.java
-rw-r--r-- 1 sridhav sridhav  1522 Feb 25 12:03 swe_report.txt
-rw-r--r-- 1 sridhav sridhav   240 Feb 25 12:17 assm_my_job.txt
-rw------- 1 sridhav sridhav     0 Feb 25 14:07 typescript
bash-4.2$ javac Sysre[K[Ktem2.java
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
bash-4.2$ pr -n [K[Kn Sytem[K[K[Kstem2.java [K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[Kls -ltr
total 128
-rw-r--r-- 1 sridhav sridhav   319 Feb 22 23:04 test_job.txt
-rw-r--r-- 1 sridhav sridhav  2183 Feb 24 11:18 Loader.java
-rw-r--r-- 1 sridhav sridhav   117 Feb 24 22:30 my_job.txt
-rw-r--r-- 1 sridhav sridhav  2598 Feb 24 23:48 Stack.java
-rw-r--r-- 1 sridhav sridhav  1036 Feb 25 00:04 Memory.java
-rw-r--r-- 1 sridhav sridhav  1869 Feb 25 00:58 System2.java
drwxr-xr-x 2 sridhav sridhav  4096 Feb 25 01:00 test_files
drwxr-xr-x 2 sridhav sridhav  4096 Feb 25 10:34 assmcode
-rw-r--r-- 1 sridhav sridhav  6484 Feb 25 10:55 Variables.java
-rw-r--r-- 1 sridhav sridhav  5192 Feb 25 10:56 ErrorHandler.java
-rw-r--r-- 1 sridhav sridhav 16584 Feb 25 11:28 CPU.java
-rw-r--r-- 1 sridhav sridhav  1522 Feb 25 12:03 swe_report.txt
-rw-r--r-- 1 sridhav sridhav   240 Feb 25 12:17 assm_my_job.txt
-rw------- 1 sridhav sridhav     0 Feb 25 14:07 typescript
-rw------- 1 sridhav sridhav  5465 Feb 25 14:07 Variables.class
-rw------- 1 sridhav sridhav  1099 Feb 25 14:07 System2.class
-rw------- 1 sridhav sridhav   911 Feb 25 14:07 Stack$Node.class
-rw------- 1 sridhav sridhav  1505 Feb 25 14:07 Stack$ListIterator.class
-rw------- 1 sridhav sridhav  2107 Feb 25 14:07 Stack.class
-rw------- 1 sridhav sridhav   166 Feb 25 14:07 Stack$1.class
-rw------- 1 sridhav sridhav   695 Feb 25 14:07 Memory.class
-rw------- 1 sridhav sridhav  1881 Feb 25 14:07 Loader.class
-rw------- 1 sridhav sridhav  4107 Feb 25 14:07 ErrorHandler.class
-rw------- 1 sridhav sridhav  8102 Feb 25 14:07 CPU.class
bash-4.2$ pr -n System2.java 


2014-02-25 00:58                   System2.java                   Page 1


    1	
    2	import java.io.File;
    3	import java.io.FileWriter;
    4	import java.io.IOException;
    5	import java.util.Scanner;
    6	
    7	public class System2 {
    8	    /*
    9	    a. Sridhar Vemula
   10	    b. CS 5323
   11	    c. A Simple Batch System(Step 1)
   12	    d. 2/23/2014
   13	    e. All the global Variables(which are static) are declared in Variables.java
   14	    f. The System Routine is the Driver for the simulation. It has the objects for Loader and CPU class.
   15	    the Loader loads data from input device(file) to main memory. After the program is loaded
   16	    it needs to be executed. The CPU object executes the Instructions.
   17	    g. As the Object Oriented model I divided every module to a individual Class. So in order to have the
   18	    global Variables to be distributed among these classes I have used Variables class and declared some static
   19	    public variables which can be used by all Classes. The imp Global Variables like PC,IR, CLOCK, MEM etc., are
   20	    declared here. And In Java it doesnt allow me to pass Value by Reference. So In order to do this rather than
   21	    seding X, Y values am sending the static Variables that are Saved(Its the same. But As am not Using the exact
   22	    specified variables thought to give a note)
   23	    */
   24	    
   25	    public static void main(String[] args) throws IOException, Exception {
   26	       
   27	        FileWriter fw=new FileWriter("trace_file.txt");
   28	        fw.write("PC  \tBR  \tIR  \tTOS \tS[TOS]\tEA  \tMEM[EA]\tTOS \tS[TOS]\tEA  \tMEM[EA]\t\n\n");
   29	        fw.close();
   30	
   31	        File f=new File("output_file.txt");
   32	        if(f.exists()){
   33	            f.delete();
   34	        }
   35	        if(args.length!=1){
   36	            System.out.println("Usage: java System2 <file-name>");
   37	            System.exit(0);
   38	        }
   39	        Variables.loadFile=args[0];
   40	        Loader x=new Loader(0,1);
   41	        CPU m=new CPU(Variables.IPC,Variables.CPU_TRACE);
   42	    }
   43	    
   44	}

















bash-4.2$ pr -n Loader.hj[K[Kjava 


2014-02-24 11:18                   Loader.java                    Page 1


    1	
    2	import java.io.BufferedReader;
    3	import java.io.FileNotFoundException;
    4	import java.io.FileReader;
    5	import java.io.IOException;
    6	
    7	/*
    8	f. the Loader is responsible for loading the data from input(file) to Memory. The hex file is loaded
    9	and the Loader calls the Memory Module to write to memory. It Handles two errors Invalid Trace Flag
   10	error and Invalid Loader Format Error.
   11	
   12	g. The Loader Job accurately implements the Specification.
   13	
   14	*/
   15	public class Loader {
   16	    private String store="";
   17	    private String data="";
   18	    private Memory memory;
   19	    public Loader(int X,int Y) throws IOException, Exception{
   20	        
   21	        Variables.CPU_TRACE=Y;
   22	        readLoader(Variables.loadFile);
   23	    }
   24	    
   25	    /*
   26	    The readLoader Method takes the data from the file and writes them into the Memory.
   27	    The Initial PC, Trace flag, mem_size, Load Address and JOB_ID gets stored in global variables
   28	    which are given in the file.
   29	    
   30	    */
   31	    
   32	    private void readLoader(String load) throws FileNotFoundException, IOException, Exception {
   33	        BufferedReader br=new BufferedReader(new FileReader(load));
   34	        String temp;
   35	        while((temp=br.readLine())!=null){
   36	            store=store+temp+"\n";
   37	        }        
   38	        String lines[]=store.split("\\r?\\n");
   39	        for(int i=1;i<lines.length;i++){
   40	            data=data+lines[i];
   41	        } 
   42	        String[] top=lines[0].split("\\s");
   43	        
   44	        Variables.JOB_ID=Byte.parseByte(top[0],16);
   45	        Variables.LA=Byte.parseByte(top[1],16);
   46	        Variables.IPC=Byte.parseByte(top[2],16);
   47	        Variables.mem_size=Byte.parseByte(top[3],16);
   48	        Variables.CPU_TRACE=Byte.parseByte(top[4],16);
   49	        
   50	        int j=0;
   51	        Variables.BR=Variables.LA;
   52	        
   53	        for(int i=0;i<Variables.mem_size;i++){
   54	            ErrorHandler.checkLoaderFormat(data.substring(j,j+4));
   55	            String X="WRITE";
   56	            int Y=i;







2014-02-24 11:18                   Loader.java                    Page 2


   57	            int Z=Integer.parseInt(data.substring(j,j+4),16);
   58	            memory=new Memory();
   59	            memory.writeMemory(Y, Z);
   60	            ErrorHandler.checkMemoryAdressBound(i);
   61	            j=j+4;
   62	        } 
   63	    }
   64	 
   65	}




















































bash-4.2$ pr -nm [K[K me[K[KMemory.java 


2014-02-25 00:04                   Memory.java                    Page 1


    1	
    2	import java.io.IOException;
    3	
    4	/*
    5	
    6	f. The Memory Routine reads and writes data to the Memory. Its the sole job of Memory
    7	An Error Handler for MemoryAddressBound is checked. If error is present it terminates.
    8	MemoryAddressBound -> If EA is greater than 256 | EA is less than 0
    9	
   10	g. As Java doesnot allow pass by reference. I could not use the Procedure MEMORY(X,Y,Z).
   11	So I need to create to other Methods readMemory to Read From Memory, and writeMemory
   12	to write to memory. The overall functionality doesnot change except for the Specification
   13	
   14	*/
   15	
   16	public class Memory {
   17	    
   18	   public int readMemory(int Y) throws IOException{
   19	        ErrorHandler.checkMemoryAdressBound(Variables.BR+Y);
   20	        Integer x=new Integer(Variables._MEM[Variables.BR+Y]);
   21	        short y=x.shortValue();
   22	        x=(int)y;
   23	        return x;
   24	    } 
   25	    
   26	    public void writeMemory(int Y,int Z) throws IOException{
   27	        ErrorHandler.checkMemoryAdressBound(Variables.BR+Y);
   28	        Variables._MEM[Variables.BR+Y]=Z;
   29	    }
   30	    
   31	}






























bash-4.2$ pr -n CP[K[KCPu[KU.java 


2014-02-25 11:28                     CPU.java                     Page 1


    1	
    2	import java.io.IOException;
    3	import java.util.Scanner;
    4	
    5	/*
    6	f. The Core of the Operating System. Executes the 1 address and 0 address Instructions. Errors like
    7	Invalid Opcode, Arithematic Divide by zero are handled. Warmings like Infinite loop and invalid input
    8	value are handled in here.
    9	
   10	g. Implemented as Specified. More methods are seen here as there are many blocks used multiple times i thought
   11	it would better to use methods.
   12	*/
   13	
   14	public class CPU {
   15	    String mem_val;
   16	    String operation;
   17	    int indexed;
   18	    int DADDR;
   19	    String opName="";
   20	    Memory m=new Memory();
   21	    
   22	    /*
   23	    CPU the PC and CPU_TRACE_FLAG are added
   24	    */
   25	    
   26	    public CPU(int X,int Y) throws IOException,Exception{
   27	        Variables.PC=X;
   28	        if(Y==1 || Y==0){
   29			Variables.CPU_TRACE=Y;
   30	        }
   31		else{
   32			ErrorHandler.throwWarning(ErrorHandler.WR_CPU_INVALID_FLAG);
   33			Variables.CPU_TRACE=0;
   34		}
   35		/*
   36	        While Condition is run until a HLT operation is observed
   37	        PC is Incremented for Every operation.
   38	        FETCHES INSTRUCTION
   39	        */
   40	        while(!opName.equals("HLT")){
   41	            Variables.IR=m.readMemory(Variables.PC);
   42	            mem_val=getMemValue(Variables.IR); 
   43	            /*
   44	            Previous Stack and Memory values for trace files
   45	            */
   46	            Variables.prev_tos=Variables._STACK.size();
   47	            if(Variables._STACK.isEmpty()){
   48	                Variables.prev_stack_val="EMPTY";
   49	            }
   50	            else{
   51	                int val=(int) Variables._STACK.pop();
   52	                Variables.prev_stack_val=Variables.toHex(0);
   53	                Variables._STACK.push(val);
   54	            }
   55	            Variables.prev_ea=Variables.EA;
   56	            







2014-02-25 11:28                     CPU.java                     Page 2


   57	            splitInstruction(mem_val);
   58	            Variables.PC++;
   59	            
   60	            if(Y==1){
   61	                Variables.writeToTraceFile();
   62	            }
   63	        }
   64	        
   65	    }
   66	    
   67	    /*
   68	    DECODES THE INSTRUCTION
   69	    */
   70	    
   71	    private void splitInstruction(String mem_val) throws InterruptedException, IOException {
   72	        if(getType(mem_val)==1){
   73	            operation=mem_val.substring(1,6);
   74	            indexed=Integer.parseInt(mem_val.charAt(6)+"");
   75	            String temp=mem_val.substring(9,mem_val.length());
   76	            DADDR=Integer.parseInt(temp,2);
   77	            if(indexed==1){
   78	                Variables.EA=DADDR+Variables._MEM[(int)Variables._STACK.pop()];
   79	                String EAVal="000000000000000000000000000"+Integer.toBinaryString(Variables.EA);
   80	                EAVal=EAVal.substring(EAVal.length()-7,EAVal.length());
   81	                Variables.EA=Integer.parseInt(EAVal,2);
   82	            }
   83	            else{
   84	                Variables.EA=DADDR;
   85	                
   86	            }
   87	            runInstruction16();
   88	        }
   89	        if(getType(mem_val)==0){
   90	            operation = mem_val.substring(3,8);
   91	            runInstruction8();
   92	            if(!opName.equals("RTN")){
   93	                operation=mem_val.substring(11,mem_val.length());
   94	                runInstruction8();
   95	            }
   96	        }
   97	    }
   98	    
   99	    /*
  100	    EXECUTES THE INSTRUCTION - LONG -16 BIT INSTRUCTIONS(ONE ADRESS INSTRUCTIONS)
  101	    
  102	    CYCLOMATIC COMPLEXITY = 33 as all instructions are written under switch.
  103	    Many decisions to make.
  104	    */
  105	    
  106	    private void runInstruction16() throws InterruptedException, IOException {
  107	        
  108	        switch(operation){
  109	            case "00000": opName="NOP";
  110	            break;
  111	            case "00001": opName="OR";
  112	            Variables._STACK.push((int)Variables._STACK.pop() | m.readMemory(Variables.EA));







2014-02-25 11:28                     CPU.java                     Page 3


  113	            break;
  114	                
  115	            case "00010": opName="AND";
  116	            Variables._STACK.push((int)Variables._STACK.pop() & m.readMemory(Variables.EA));
  117	            break;
  118	                               
  119	            case "00100": opName="XOR";
  120	            Variables._STACK.push((int)Variables._STACK.pop() ^ m.readMemory(Variables.EA));
  121	            break;
  122	                
  123	            case "00101": opName="ADD";
  124	            Variables._STACK.push((int)Variables._STACK.pop() + m.readMemory(Variables.EA));
  125	            break;
  126	                
  127	            case "00110": opName="SUB";
  128	            Variables._STACK.push((int)Variables._STACK.pop() - m.readMemory(Variables.EA));
  129	            break;
  130	                
  131	            case "00111": opName="MUL";
  132	            int temp=(int)Variables._STACK.pop() * m.readMemory(Variables.EA);
  133	            if(temp>32767 || temp<-32768){
  134	                ErrorHandler.throwWarning(ErrorHandler.WR_VALUE_OUT_OF_RANGE);
  135	                temp=0;
  136	            }
  137	            Variables._STACK.push(temp);
  138	            break;
  139	                
  140	            case "01000": opName="DIV";
  141	            int x=m.readMemory(Variables.EA);
  142	            if(x==0){
  143	                ErrorHandler.throwError(ErrorHandler.ER_ARI_DIVIDE_BY_ZERO);
  144	            }
  145	            Variables._STACK.push((int)Variables._STACK.pop() / m.readMemory(Variables.EA));
  146	            break;
  147	                
  148	            case "01001": opName="MOD";
  149	            x=m.readMemory(Variables.EA);
  150	            if(x==0){
  151	                ErrorHandler.throwError(ErrorHandler.ER_ARI_DIVIDE_BY_ZERO);
  152	            }
  153	            Variables._STACK.push((int)Variables._STACK.pop() % m.readMemory(Variables.EA));
  154	            break;
  155	                
  156	            case "01100": 
  157	                /*
  158	                Infinite Loop Check: The index Variable is checked Everytime
  159	                with the previous value; If both are the same for 5 times. The
  160	                Warning Infinite Loop is issued. I have considered Infinite Loop as
  161	                warning because it might be users interest to run a job infinitely.
  162	                The same has been represented in CPL and CPE
  163	                */
  164	                opName="CPG";
  165	                int val=(int)Variables._STACK.pop();
  166	                Variables._STACK.push(val);
  167	                
  168	                Variables.now_index_value=val;







2014-02-25 11:28                     CPU.java                     Page 4


  169	                if(Variables.prev_index_value==Variables.now_index_value){
  170	                    Variables.index_count++;
  171	                    if(Variables.index_count==5){
  172	                        ErrorHandler.throwWarning(ErrorHandler.WR_INF_LOOP);
  173	                    }
  174	                }
  175	                Variables.prev_index_value=Variables.now_index_value;
  176	                
  177	                if(val>m.readMemory(Variables.EA)){
  178	                    Variables._STACK.push(1);
  179	                }
  180	                else{
  181	                    Variables._STACK.push(0);
  182	                }
  183	                break;
  184	                
  185	            case "01101": opName="CPL";
  186	            val=(int)Variables._STACK.pop();
  187	            Variables._STACK.push(val);
  188	            Variables.now_index_value=val;
  189	            if(Variables.prev_index_value==Variables.now_index_value){
  190	                Variables.index_count++;
  191	            }
  192	            if(Variables.index_count==5){
  193	                ErrorHandler.throwWarning(ErrorHandler.WR_INF_LOOP);
  194	            }
  195	            Variables.prev_index_value=Variables.now_index_value;
  196	            
  197	            if(val<m.readMemory(Variables.EA)){
  198	                Variables._STACK.push(1);
  199	            }
  200	            else{
  201	                Variables._STACK.push(0);
  202	            }
  203	            break;
  204	                
  205	            case "01110": opName="CPE";
  206	            val=(int)Variables._STACK.pop();
  207	            Variables._STACK.push(val);
  208	            Variables.now_index_value=val;
  209	            if(Variables.prev_index_value==Variables.now_index_value){
  210	                Variables.index_count++;
  211	                if(Variables.index_count==5){
  212	                    ErrorHandler.throwWarning(ErrorHandler.WR_INF_LOOP);
  213	                }
  214	            }
  215	            Variables.prev_index_value=Variables.now_index_value;
  216	            if(val==m.readMemory(Variables.EA)){
  217	                Variables._STACK.push(1);
  218	            }
  219	            else{
  220	                Variables._STACK.push(0);
  221	            }
  222	            break;
  223	                
  224	            case "01111": opName="BR";







2014-02-25 11:28                     CPU.java                     Page 5


  225	            Variables.PC=Variables.EA-1;
  226	            break;
  227	                
  228	            case "10000": opName="BRT";
  229	            if((int)Variables._STACK.pop()==1){
  230	                Variables.PC=Variables.EA-1;
  231	            }
  232	            break;
  233	                
  234	            case "10001": opName="BRF";
  235	            if((int)Variables._STACK.pop()==0){
  236	                Variables.PC=Variables.EA-1;
  237	            }
  238	            break;
  239	                
  240	            case "10010": opName="CALL";
  241	            Variables._STACK.push(Variables.PC);
  242	            Variables.PC=Variables.EA-1;
  243	            break;
  244	          
  245	            case "10110": opName="PUSH";
  246	            Variables._STACK.push(m.readMemory(Variables.EA));
  247	            break;
  248	                
  249	            case "10111": opName="POP";
  250	            m.writeMemory(Variables.EA,(int)Variables._STACK.pop());
  251	            break;
  252	                
  253	            default : ErrorHandler.throwError(ErrorHandler.ER_CPU_INVALID_OPCODE);
  254	            break;
  255	        }
  256	        Variables._CLOCK+=4;
  257	        
  258	    }
  259	    
  260	    /*
  261	    EXECUTES THE INSTRUCTION - Short-8 BIT INSTRUCTIONS(ZERO ADRESS INSTRUCTIONS)
  262	    CYCLOMATIC COMPLEXITY = 33 as all instructions are written under switch.
  263	    Many decisions to make.
  264	    */
  265	    
  266	    private void runInstruction8() throws InterruptedException, IOException {
  267	        
  268	        switch(operation){
  269	            case "00000": opName="NOP";
  270	            break;
  271	                
  272	            case "00001": opName="OR";
  273	            Variables._STACK.push((int)Variables._STACK.pop() | (int)Variables._STACK.pop());
  274	            break;
  275	                
  276	            case "00010": opName="AND";
  277	            Variables._STACK.push((int)Variables._STACK.pop() & (int)Variables._STACK.pop());
  278	            break;
  279	                
  280	            case "00011": opName="NOT";







2014-02-25 11:28                     CPU.java                     Page 6


  281	            Variables._STACK.push(~((int)Variables._STACK.pop()));
  282	            break;
  283	                
  284	            case "00100": opName="XOR";
  285	            Variables._STACK.push((int)Variables._STACK.pop() ^ (int)Variables._STACK.pop());
  286	            break;
  287	                
  288	            case "00101": opName="ADD";
  289	            Variables._STACK.push((int)Variables._STACK.pop() + (int)Variables._STACK.pop());
  290	            break;
  291	                
  292	            case "00110": opName="SUB";
  293	            Variables._STACK.push((int)Variables._STACK.pop() - (int)Variables._STACK.pop());
  294	            break;
  295	                
  296	            case "00111": opName="MUL";
  297	            int temp=(int)Variables._STACK.pop() * (int)Variables._STACK.pop();
  298	            if(temp>32767 || temp<-32768){
  299	                ErrorHandler.throwWarning(ErrorHandler.WR_VALUE_OUT_OF_RANGE);
  300	                temp=0;
  301	            }
  302	            Variables._STACK.push(temp);
  303	            break;
  304	                
  305	            case "01000": opName="DIV";
  306	            int x=(int) Variables._STACK.pop();
  307	            if(x==0){
  308	                ErrorHandler.throwError(ErrorHandler.ER_ARI_DIVIDE_BY_ZERO);
  309	            }
  310	            Variables._STACK.push((int)Variables._STACK.pop() / x);
  311	            break;
  312	                
  313	            case "01001": opName="MOD";
  314	            x=(int) Variables._STACK.pop();
  315	            if(x==0){
  316	                ErrorHandler.throwError(ErrorHandler.ER_ARI_DIVIDE_BY_ZERO);
  317	            }
  318	            Variables._STACK.push((int)Variables._STACK.pop() % x);
  319	            break;
  320	            
  321	            case "01010": opName="SL";
  322	            Variables._STACK.push((int)Variables._STACK.pop()<<1);
  323	            break;
  324	                
  325	            case "01011": opName="SR";
  326	            Variables._STACK.push((int)Variables._STACK.pop()>>1);
  327	            break;
  328	                
  329	            case "01100": /*
  330	                Infinite Loop Check: The index Variable is checked Everytime
  331	                with the previous value; If both are the same for 5 times. The
  332	                Warning Infinite Loop is issued. I have considered Infinite Loop as
  333	                warning because it might be users interest to run a job infinitely.
  334	                The same has been represented in CPL and CPE
  335	                */
  336	                opName="CPG";







2014-02-25 11:28                     CPU.java                     Page 7


  337	                int val=(int)Variables._STACK.pop();
  338	                int val11=(int)Variables._STACK.pop();
  339	                Variables._STACK.push(val11);
  340	                Variables._STACK.push(val);
  341	                Variables.now_index_value=val;
  342	                if(Variables.prev_index_value==Variables.now_index_value){
  343	                    Variables.index_count++;
  344	                    if(Variables.index_count==5){
  345	                        ErrorHandler.throwWarning(ErrorHandler.WR_INF_LOOP);
  346	                    }
  347	                }
  348	                Variables.prev_index_value=Variables.now_index_value;
  349	                if(val11>val){
  350	                    Variables._STACK.push(1);
  351	                    
  352	                }
  353	                else{
  354	                    Variables._STACK.push(0);
  355	                }
  356	                break;
  357	                
  358	            case "01101": opName="CPL";
  359	            val=(int)Variables._STACK.pop();
  360	            val11=(int)Variables._STACK.pop();
  361	            Variables._STACK.push(val11);
  362	            Variables._STACK.push(val);
  363	            Variables.now_index_value=val;
  364	            if(Variables.prev_index_value==Variables.now_index_value){
  365	                Variables.index_count++;
  366	                if(Variables.index_count==5){
  367	                    ErrorHandler.throwWarning(ErrorHandler.WR_INF_LOOP);
  368	                }
  369	            }
  370	            Variables.prev_index_value=Variables.now_index_value;
  371	            if(val11<val){
  372	                Variables._STACK.push(1);
  373	                
  374	            }
  375	            else{
  376	                Variables._STACK.push(0);
  377	            }
  378	            break;
  379	                
  380	            case "01110": opName="CPE";
  381	            val=(int)Variables._STACK.pop();
  382	            val11=(int)Variables._STACK.pop();
  383	            
  384	            Variables._STACK.push(val11);
  385	            Variables._STACK.push(val);
  386	            Variables.now_index_value=val;
  387	            if(Variables.prev_index_value==Variables.now_index_value){
  388	                Variables.index_count++;
  389	                if(Variables.index_count==5){
  390	                    ErrorHandler.throwWarning(ErrorHandler.WR_INF_LOOP);
  391	                }
  392	            }







2014-02-25 11:28                     CPU.java                     Page 8


  393	            Variables.prev_index_value=Variables.now_index_value;
  394	            if(val11==val){
  395	                Variables._STACK.push(1);
  396	                
  397	            }
  398	            else{
  399	                Variables._STACK.push(0);
  400	            }
  401	            break;
  402	               
  403	            case "10011": opName="RD";
  404	            readVals();
  405	            break;
  406	                
  407	            case "10100": opName="WR";
  408	            val=(int) Variables._STACK.pop();
  409	            System.out.println("OUTPUT:"+val);
  410	            Variables.OUTPUT=Variables.OUTPUT+""+val+"\n";
  411	            Variables._CLOCK=Variables._CLOCK+14;
  412	            Variables.IO_CLOCK=Variables.IO_CLOCK+14;
  413	            break;
  414	                
  415	            case "10101": opName="RTN";
  416	            Variables.PC=(int) Variables._STACK.pop();
  417	            break;
  418	            
  419	            case "11000":opName="HLT";
  420	            Variables.writeToOutputFile();
  421	            break;
  422	                
  423	            default : ErrorHandler.throwError(ErrorHandler.ER_CPU_INVALID_OPCODE);
  424	            break;
  425	        }
  426	        
  427	        Variables._CLOCK++;
  428	         
  429	    }
  430	    
  431	    /*
  432	    Due to the complexity of code the Read Operation is declared HERE
  433	    RD Operation. Throws an Warning if values are more than 16bits
  434	    */
  435	    
  436	    private void readVals() throws InterruptedException, IOException {
  437	        System.out.println("ENTER INPUT:");
  438	        Scanner sc=new Scanner(System.in);
  439	        int temp=sc.nextInt();
  440	        if(temp>32767 || temp<-32768){
  441	            ErrorHandler.throwWarning(ErrorHandler.WR_VALUE_OUT_OF_RANGE);
  442	            temp=0;
  443	        }
  444	        Variables._STACK.push(temp);
  445	        Variables._CLOCK=Variables._CLOCK+14;
  446	        Variables.IO_CLOCK=Variables.IO_CLOCK+14;
  447	    }
  448	    







2014-02-25 11:28                     CPU.java                     Page 9


  449	    /*
  450	    OTHER METHODS (MISC)
  451	    USED TO PAD THE BINARY BITS
  452	    */
  453	    
  454	    private String getMemValue(int i) {
  455	        String temp;
  456	        temp=Integer.toBinaryString(i);
  457	        temp="00000000000000000"+temp;
  458	        temp=temp.substring(temp.length()-16,temp.length());
  459	        return temp;
  460	    }
  461	    
  462	    /*
  463	    OTHER METHODS (MISC)
  464	    TO GET THE TYPE OF INSTRUCTION BY GETTING THE FIRST BIT
  465	    */
  466	    
  467	    private int getType(String mem_val) {
  468	        return Integer.parseInt(mem_val.charAt(0)+"");
  469	    }
  470	}







































bash-4.2$ pr -n ErrorHandler.java 


2014-02-25 10:56                ErrorHandler.java                 Page 1


    1	
    2	import java.io.IOException;
    3	import java.util.Scanner;
    4	
    5	/*
    6	f.All the Errors and Warining are given Different integer values.
    7	The Error Handler catches the Errors and displays the Reason for errors.
    8	
    9	Most Runtime errors are caught here
   10	g. Error handler is given a Separate class in order for modularity. For code Understandability
   11	I preffered this.
   12	*/
   13	
   14	public class ErrorHandler {
   15	    /*
   16	    ERROR CODES
   17	    */
   18	    
   19	    public final static int ER_LOADER_INVALID_FORMAT=1;
   20	    public final static int WR_LOADER_INVALID_FLAG=2;
   21	    public final static int ER_LOADER_INVALID_IPC=3;
   22	    public final static int ER_LOADER_INVALID_SIZE=4;
   23	    
   24	    public final static int ER_STACK_OVERFLOW=11;
   25	    public final static int ER_STACK_UNDERFLOW=12;
   26	    
   27	    public final static int ER_MEM_OUT_OF_RANGE=21;
   28	    
   29	    public final static int ER_ARI_DIVIDE_BY_ZERO=31;
   30	    
   31	    public final static int WR_INF_LOOP=101;
   32	    public static final int ER_CPU_INVALID_OPCODE=41;
   33	    public final static int WR_CPU_INVALID_FLAG=42;
   34	    public final static int WR_VALUE_OUT_OF_RANGE=51;
   35	    
   36	    public static int NATURE=1;
   37	    
   38	    
   39	    public static String Error="";
   40	    public static String stack_trace="";
   41	    public static String Warning="";
   42	    
   43	    /*
   44	    Warnings are Caught and the program execution completes but a Warning
   45	    Appears on the output file
   46	    */
   47	    
   48	    public static void throwWarning(int err) throws InterruptedException, IOException {
   49	        Warning=Warning+"WARNINGS\n";
   50	        switch(err){
   51	            case WR_CPU_INVALID_FLAG: Warning=Warning+"Warning : Invalid CPU Trace Flag. Default 0 is taken\n";
   52	            break;
   53	            case WR_LOADER_INVALID_FLAG:Warning=Warning+"Warning : Invalid Loader Trace Flag. Default 0 is taken\n";
   54	            break;
   55	            case WR_VALUE_OUT_OF_RANGE:Warning=Warning+"Warning : Invalid Input. Input Ranges between -32768 to 32767\n";
   56	            break;







2014-02-25 10:56                ErrorHandler.java                 Page 2


   57	            case WR_INF_LOOP:Warning=Warning+"Warning : Possibility of Infinite Loop\n";
   58	            System.out.println("WARNING : Possibility of Infinite Loop. Press 1 to exit");
   59	            Scanner sc=new Scanner(System.in);
   60	            int inp=sc.nextInt();
   61	            if(inp==1){
   62	                Variables.writeToOutputFile();
   63	            }
   64	            System.exit(0);
   65	            break;
   66	                
   67	        }
   68	        Warning=Warning+"\n";
   69	    }
   70	    
   71	    /*
   72	    Erros are Caught and the program execution terminates with abnormal behaviour
   73	    Error Appears on the output file. A Stack Trace is also shown if any syntax errors
   74	    */
   75	    
   76	    public static void throwError(int err) throws IOException{
   77	        Error=Error+"ERRORS :\n";
   78	        switch(err){
   79	            case ER_LOADER_INVALID_FORMAT: Error=Error+"Error : INVALID LOADER FORMAT";
   80	            NATURE=0;
   81	            break;
   82	            case ER_LOADER_INVALID_IPC : Error=Error+"Error : INVALID LOADER IPC";
   83	            NATURE=0;
   84	            break;
   85	            case ER_LOADER_INVALID_SIZE : Error=Error+"Error : INVALID LOADER SIZE VALUE";
   86	            NATURE=0;
   87	            break;
   88	            case ER_STACK_OVERFLOW:Error=Error+"Error : STACK OVERFLOW";
   89	            NATURE=0;
   90	            break;
   91	            case ER_STACK_UNDERFLOW:Error=Error+"STACK UNDERFLOW";
   92	            NATURE=0;
   93	            break;
   94	            case ER_MEM_OUT_OF_RANGE:Error=Error+"Error: MEMORY OUT OF RANGE";
   95	            NATURE=0;
   96	            break;
   97	            case ER_ARI_DIVIDE_BY_ZERO:Error=Error+"Error: ARITHEMATIC DIVIDE BY ZERO";
   98	            NATURE=0;
   99	            break;
  100	            case ER_CPU_INVALID_OPCODE: Error=Error+"Error : INVALID OPCODE";
  101	            NATURE=0;
  102	            break;
  103	        }
  104	        Error=Error+"\n";
  105	        PrintStackTrace();
  106	        Variables.writeToOutputFile();
  107	        System.out.println("ERROR");
  108	        System.exit(0);
  109	    }
  110	    
  111	    /*
  112	    Prints Stack Trace when there is an Error







2014-02-25 10:56                ErrorHandler.java                 Page 3


  113	    */
  114	    
  115	    private static void PrintStackTrace() {
  116	        stack_trace=stack_trace+"STACK TRACE\n";
  117	        StackTraceElement[] st=Thread.currentThread().getStackTrace();
  118	        for(int i=1;i<st.length;i++){
  119	            stack_trace=stack_trace+"Class Name :"+st[i].getFileName()+" Method Name :"+st[i].getMethodName()+" Line Number:"+st[i].getLineNumber()+"\n";
  120	        }
  121	        stack_trace=stack_trace+"\n";
  122	
  123	    }
  124	    
  125	    /*
  126	    The Error Check Methods are also declared here. These are declared static
  127	    So these can be used in all the classes in the simulation
  128	    Checks the Loader format. If Loader has characters like z,x which are not hex values
  129	    Error is returned.
  130	    */
  131	    
  132	    public static void checkLoaderFormat(String str) throws IOException {
  133	        str=str.toUpperCase();
  134	        if(!str.matches("[A-F0-9]{4}")){
  135	            System.out.println(str);
  136	            ErrorHandler.throwError(ErrorHandler.ER_LOADER_INVALID_FORMAT);
  137	        }
  138	    }
  139	    
  140	    /*
  141	    Checks the address if Memory address thats being asked to check is greater
  142	    than 256 or less than 0 error is caught
  143	    */
  144	    
  145	    public static void checkMemoryAdressBound(int i) throws IOException {
  146	        if(i>=256 | i<0){
  147	            ErrorHandler.throwError(ErrorHandler.ER_MEM_OUT_OF_RANGE);
  148	        }
  149	    }
  150	    
  151	}






















bash-4.2$ pr -n Variables.java 


2014-02-25 10:55                  Variables.java                  Page 1


    1	
    2	import java.io.File;
    3	import java.io.FileWriter;
    4	import java.io.IOException;
    5	import java.util.Iterator;
    6	import java.util.NoSuchElementException;
    7	
    8	/*
    9	g. So in order to have the global Variables to be distributed among these classes I have used Variables class
   10	and declared some static public variables which can be used by all Classes. The imp Global Variables like
   11	PC,IR, CLOCK, MEM etc., are declared here.
   12	*/
   13	
   14	public class Variables {
   15	    
   16	    public static int TOS;
   17	    public static int PC;
   18	    public static int IR;
   19	    public static int BR;
   20	    public static int EA;
   21	    
   22	    public static Stack _STACK=new Stack();
   23	    public static int _MEM[]=new int[256];
   24	    
   25	    /*
   26	    USED FOR CHECKING AN INFINITE LOOP
   27	    */
   28	    
   29	    public static int prev_index_value=0;
   30	    public static int now_index_value=0;
   31	    public static int index_count=0;
   32	    
   33	    /*
   34	    LOADER OBTAINED VARIABLES FROM INPUT FILE.
   35	    */
   36	    
   37	    public static int JOB_ID;
   38	    public static int LA;
   39	    public static int IPC;
   40	    public static int CPU_TRACE=0;
   41	    public static int mem_size;
   42	    
   43	    
   44	    public static long _CLOCK=0;
   45	    public static long IO_CLOCK=0;
   46	   
   47	    public static int prev_tos=0;
   48	    public static int prev_ea=0;
   49	    public static String prev_stack_val;
   50	    
   51	    /*
   52	    LOADER INPUT FILE
   53	    */
   54	    
   55	    public static String loadFile;
   56	   







2014-02-25 10:55                  Variables.java                  Page 2


   57	    /*
   58	    OUTPUT FROM WRITE. Trace date to be written into Trace file
   59	    */
   60	
   61	    public static String OUTPUT="";
   62	    public static String traceData="";
   63	   
   64	    /*
   65	    Method to write to trace_file.txt
   66	    */
   67	    
   68	    public static void writeToTraceFile() throws IOException,NoSuchElementException{
   69	        FileWriter fw=new FileWriter("./trace_file.txt",true);
   70	        String temp="";
   71	        String Stack_val;
   72	        if(Variables._STACK.isEmpty()){
   73	            Stack_val="EMPTY";
   74	        }
   75	        else{
   76	            int val=(int) Variables._STACK.pop();
   77	            Stack_val=toHex(val);
   78	            Variables._STACK.push(val);
   79	        }
   80	        
   81	        temp=temp+""+toHex(Variables.PC)+"\t"+toHex(Variables.BR)+"\t"+toHex(Variables.IR)+"\t"+toHex(Variables.prev_tos)+"\t"+prev_stack_val+"\t"+toHex(prev_ea)+"\t"+toHex(_MEM[prev_ea])+"\t"+toHex(Variables._STACK.size())+"\t"+Stack_val+"\t"+toHex(EA)+"\t"+toHex(Variables._MEM[EA]);
   82	        temp=temp+"\n";
   83	        fw.write(temp);
   84	        fw.close();
   85	    }
   86	    
   87	    /*
   88	    Method to write to output_file.txt
   89	    */
   90	    
   91	    public static void writeToOutputFile() throws IOException,NoSuchElementException{
   92	        
   93	        FileWriter fw=new FileWriter("./output_file.txt",false);
   94	        String temp="JOB ID :\t";
   95	        temp=temp+JOB_ID+"\n\n";
   96	        temp=temp+ErrorHandler.Error;
   97	        temp=temp+ErrorHandler.stack_trace;
   98	        temp=temp+ErrorHandler.Warning;
   99	        if(ErrorHandler.NATURE==1){
  100	            temp=temp+"NORMAL EXECUTION\n";
  101	        }
  102	        if(ErrorHandler.NATURE==0){
  103	            temp=temp+"ABNORMAL EXECUTION\n\n";
  104	            temp=temp+writeMemoryDump();
  105	            temp=temp+"\n";
  106	        }
  107	        temp=temp+"OUTPUT:\n"+OUTPUT+"\n\n";
  108	        temp=temp+"CLOCK   (HEX):\t"+toHex((int) _CLOCK)+"\n";
  109	        temp=temp+"Run Time(DEC):\t"+(long)(_CLOCK)+"\n";
  110	        temp=temp+"ExecTime(DEC):\t"+(long)(_CLOCK-IO_CLOCK)+"\n";
  111	        temp=temp+"I/O Time(DEC):\t"+(long)IO_CLOCK+"\n";
  112	        fw.write(temp);







2014-02-25 10:55                  Variables.java                  Page 3


  113	        fw.close();
  114	    }
  115	    
  116	    /*
  117	    Write to Memory Dump
  118	    */
  119	    
  120	    private static String writeMemoryDump() {
  121	        String temp2="MEMORY DUMP\n";
  122	       temp2=temp2+"HEX \t"+ "Binary Value\n";
  123	        for(int i=0;i<mem_size;i++){
  124	            int x=_MEM[i];
  125	            String temp="000000"+Integer.toHexString(x);
  126	            String temp3="00000000000000000000000000000"+Integer.toBinaryString(x);
  127	            temp3=temp3.substring(temp3.length()-16,temp3.length());
  128	            temp2=temp2+temp.substring(temp.length()-4,temp.length())+"\t"+temp3+"\n";
  129	        }
  130	        return temp2;
  131	    }
  132	    
  133	    /*
  134	    converts to Hex values;
  135	    */
  136	    
  137	    public static String toHex(int val) {
  138	        String temp="000000000"+Integer.toHexString(val);
  139	        temp=temp.substring(temp.length()-4,temp.length());
  140	        return temp;
  141	    }
  142	    
  143	    /*
  144	    Debug Methods while coding & Testing
  145	    Displays all global Variables,Mem & Stack
  146	    */
  147	    
  148	    public static void display(){
  149	        System.out.format("Top of Stack :%-30d",TOS);
  150	        System.out.format("Program Counter:%-30d",PC);
  151	        System.out.format("Instruction Register:%-30d",IR);
  152	        System.out.format("Base Register:%-30d",BR);
  153	        System.out.format("Effective Address:%-30d",EA);
  154	        System.out.format("Job ID:%-30d", JOB_ID);
  155	        System.out.format("Load Address:%-30d", LA);
  156	        System.out.format("Initial Program Counter:%-30d", IPC);
  157	        System.out.format("Memory Size:%-30d",mem_size);
  158	        System.out.format("Clock:%-30d",_CLOCK);
  159	        displayMem();
  160	        displayStack();
  161	    }
  162	    
  163	    /*
  164	    Debug Methods while coding & Testing
  165	    Displays Memory
  166	    */
  167	    
  168	    public static void displayMem() {







2014-02-25 10:55                  Variables.java                  Page 4


  169	        System.out.println("\n\n#######MEMORY#########");
  170	        for(int i=0;i<255;i++){
  171	            String hex=Integer.toHexString(_MEM[i]);
  172	            String bin=Integer.toBinaryString(_MEM[i]);
  173	            hex="000000000"+hex;
  174	            hex=hex.substring(hex.length()-4, hex.length());
  175	            bin="0000000000000000000000000000000000000000"+bin;
  176	            bin=bin.substring(bin.length()-16, bin.length());
  177	            hex=String.format("%4s",hex).replace(' ', '0');
  178	            bin=String.format("%32s",bin).replace(' ', '0');
  179	            System.out.println(_MEM[i]+"\t"+hex+"\t"+bin);
  180	         
  181	        }
  182	    }
  183	    
  184	    /*
  185	    Debug Methods while coding & Testing
  186	    Displays Stack Vals
  187	    */
  188	    
  189	    public static void displayStack() {
  190	        System.out.println("#########STACK###########");
  191	        Iterator m=_STACK.iterator();
  192	        while(m.hasNext()){
  193	            int val=(int) m.next();
  194	            String hex=Integer.toHexString(val);
  195	            String bin=Integer.toBinaryString(val);
  196	            hex="000000000"+hex;
  197	            hex=hex.substring(hex.length()-4, hex.length());
  198	            bin="0000000000000000000000000000000000000000"+bin;
  199	            bin=bin.substring(bin.length()-16, bin.length());
  200	            hex=String.format("%4s", hex).replace(' ', '0');
  201	            bin=String.format("%32s",bin).replace(' ','0');
  202	            System.out.println(val+"\t"+hex+"\t"+bin);
  203	        }
  204	    }
  205	  
  206	}























bash-4.2$ pr -n Stack/[K.java 


2014-02-24 23:48                    Stack.java                    Page 1


    1	
    2	import java.io.IOException;
    3	import java.util.Iterator;
    4	import java.util.logging.Level;
    5	import java.util.logging.Logger;
    6	
    7	/*
    8	f. STACK IMPLEMENTATION.
    9	Self Explanatory
   10	*/
   11	
   12	public class Stack<Item> implements Iterable<Item> {
   13	    private int N;                // size of the stack
   14	    private Node<Item> first;     // top of stack
   15	    
   16	    private static class Node<Item> {
   17	        private Item item;
   18	        private Node<Item> next;
   19	    }
   20	    
   21	    public Stack() {
   22	        first = null;
   23	        N = 0;
   24	    }
   25	    
   26	    public boolean isEmpty() {
   27	        return first == null;
   28	    }
   29	    
   30	    public int size() {
   31	        return N;
   32	    }
   33	    
   34	    public void push(Item item) throws IOException {
   35	        if(N>=7){
   36	            ErrorHandler.throwError(ErrorHandler.ER_STACK_OVERFLOW);
   37	        }
   38	        Node<Item> oldfirst = first;
   39	        first = new Node<Item>();
   40	        first.item = item;
   41	        first.next = oldfirst;
   42	        N++;       
   43	    }
   44	    
   45	    public Item pop() throws IOException {
   46	        if (isEmpty()) ErrorHandler.throwError(ErrorHandler.ER_STACK_UNDERFLOW);
   47	        Item item = first.item;        // save item to return
   48	        first = first.next;            // delete first node
   49	        N--;
   50	        return item;                   // return the saved item
   51	    }
   52	    
   53	    public Item peek() throws IOException {
   54	        if (isEmpty()) ErrorHandler.throwError(ErrorHandler.ER_STACK_UNDERFLOW);
   55	        return first.item;
   56	    }







2014-02-24 23:48                    Stack.java                    Page 2


   57	    
   58	    public String toString() {
   59	        StringBuilder s = new StringBuilder();
   60	        for (Item item : this)
   61	            s.append(item + " ");
   62	        return s.toString();
   63	    }
   64	    
   65	    public Iterator<Item> iterator() {
   66	        return new ListIterator<Item>(first);
   67	    }
   68	    
   69	    private class ListIterator<Item> implements Iterator<Item> {
   70	        private Node<Item> current;
   71	        
   72	        public ListIterator(Node<Item> first) {
   73	            current = first;
   74	        }
   75	        
   76	        public boolean hasNext()  { return current != null;                     }
   77	        
   78	        public void remove()      { throw new UnsupportedOperationException();  }
   79	        
   80	        public Item next() {
   81	            if (!hasNext()) try {
   82	                ErrorHandler.throwError(ErrorHandler.ER_STACK_UNDERFLOW);
   83	            } catch (IOException ex) {
   84	                Logger.getLogger(Stack.class.getName()).log(Level.SEVERE, null, ex);
   85	            }
   86	            Item item = current.item;
   87	            current = current.next;
   88	            return item;
   89	        }
   90	    }
   91	    
   92	}

























bash-4.2$ java System2 test_job.r[Ktxt
ENTER INPUT:
10
OUTPUT:10
OUTPUT:16298
bash-4.2$ cat -n output_file.txt
     1	JOB ID :	1
     2	
     3	NORMAL EXECUTION
     4	OUTPUT:
     5	10
     6	16298
     7	
     8	
     9	CLOCK   (HEX):	00f1
    10	Run Time(DEC):	241
    11	ExecTime(DEC):	199
    12	I/O Time(DEC):	42
bash-4.2$ cat -n swe_report.txt 
     1				## SOFTWARE ENGINEERING ISSSUES ###
     2	
     3	General Approach
     4	
     5	-I have used some pseudo code so that i can make my design easier.
     6	
     7	-I have written my simulation in Java. I used the Netbeans IDE, JDK & JRE 1.7 bundle to develop and execute my simulation. The IDE has built in debugger to debug the files.
     8	
     9	-BULK COMPLEXITIES
    10		- # of Files   	   : 7
    11		- # of Classes     : 9
    12		- # of Methods     : 36
    13		- # of Code	   : 175 + 167 + 717 = 1059
    14		- NOB		   : 175
    15		- NOC		   : 167
    16		- EXS		   : 717
    17		- NOD		   : 106
    18		- NOSF		   : 39
    19		- NOSM		   : 13
    20						NOB	NOC	EXS	NOM	NOD
    21			CPU			71	56	343	7	75
    22			ErrorHandler		25	31	95	5	16		
    23			Loader			12	11	42	2	3
    24			Memory			9	8	14	2	0
    25			Stack			18	4	70	12	4
    26			System			6	1	22	1	2
    27			Variable		34	41	131	7	6
    28						
    29						175	167	717	36	106
    30			
    31	NOB = # of blank lines, NOC= # of comments, EXS= # of Executable Statements
    32	NOM = # of Methods, NOD= # of decisions, NOSF = # of Static Variables
    33	NOSM = # of Static Methods
    34	
    35	-		DESIGNING : 30 Working Hours
    36			CODING 	  : 20 Working Hours
    37			TESTING	  : 30 Working Hours
    38			
    39	
    40	- As Java being platform independent my simulation can work in other operating systems (Windows or Linux)
    41	
    42	- As Java being an object oriented language so that to make my simulation more modular I prefer Java to others. Its gives an ease to implement Threads which might required in the future simulations(for steps 2 and 3) so I prefer it. As if there is any problem with a single class i can change only that class rather than making the code more complex to understand
    43	  
    44	  
    45	
    46	
    47	
    48	
    49	
    50	
    51	
    52	
bash-4.2$ cat -n trace_file.txt | head -60
     1	PC  	BR  	IR  	TOS 	S[TOS]	EA  	MEM[EA]	TOS 	S[TOS]	EA  	MEM[EA]	
     2	
     3	000c	000b	0013	0000	EMPTY	0000	0000	0001	000a	0000	0000
     4	000d	000b	dc2d	0001	0000	0000	0000	0000	EMPTY	002d	942c
     5	000e	000b	d82d	0000	EMPTY	002d	942c	0001	000a	002d	942c
     6	000f	000b	b029	0001	0000	002d	942c	0002	0001	0029	d82d
     7	0010	000b	c424	0002	0000	0029	d82d	0001	000a	0024	8832
     8	0011	000b	8830	0001	0000	0024	8832	0001	000a	0030	d82f
     9	0012	000b	d834	0001	0000	0030	d82f	0002	000a	0034	0000
    10	0013	000b	dc2c	0002	0000	0034	0000	0001	000a	002c	8833
    11	0000	000b	c800	0001	0000	002c	8833	0002	0013	0000	0000
    12	0001	000b	d82d	0002	0000	0000	0000	0003	000a	002d	942c
    13	0004	000b	bc04	0003	0000	002d	942c	0003	000a	0004	0000
    14	0005	000b	000a	0003	0000	0004	0000	0003	0014	0004	0000
    15	0006	000b	d82e	0003	0000	0004	0000	0004	0001	002e	bc26
    16	0007	000b	b42b	0004	0000	002e	bc26	0005	0001	002b	0003
    17	0002	000b	c002	0005	0000	002b	0003	0004	0001	0002	0000
    18	0003	000b	942a	0004	0000	0002	0000	0004	0002	002a	8833
    19	0004	000b	dc2e	0004	0000	002a	8833	0003	0014	002e	bc26
    20	0005	000b	000a	0003	0000	002e	bc26	0003	0028	002e	bc26
    21	0006	000b	d82e	0003	0000	002e	bc26	0004	0002	002e	bc26
    22	0007	000b	b42b	0004	0000	002e	bc26	0005	0001	002b	0003
    23	0002	000b	c002	0005	0000	002b	0003	0004	0002	0002	0000
    24	0003	000b	942a	0004	0000	0002	0000	0004	0003	002a	8833
    25	0004	000b	dc2e	0004	0000	002a	8833	0003	0028	002e	bc26
    26	0005	000b	000a	0003	0000	002e	bc26	0003	0050	002e	bc26
    27	0006	000b	d82e	0003	0000	002e	bc26	0004	0003	002e	bc26
    28	0007	000b	b42b	0004	0000	002e	bc26	0005	0001	002b	0003
    29	0002	000b	c002	0005	0000	002b	0003	0004	0003	0002	0000
    30	0003	000b	942a	0004	0000	0002	0000	0004	0004	002a	8833
    31	0004	000b	dc2e	0004	0000	002a	8833	0003	0050	002e	bc26
    32	0005	000b	000a	0003	0000	002e	bc26	0003	00a0	002e	bc26
    33	0006	000b	d82e	0003	0000	002e	bc26	0004	0004	002e	bc26
    34	0007	000b	b42b	0004	0000	002e	bc26	0005	0000	002b	0003
    35	0008	000b	c002	0005	0000	002b	0003	0004	0004	0002	0000
    36	0009	000b	dc2e	0004	0000	0002	0000	0003	00a0	002e	bc26
    37	000a	000b	dc2f	0003	0000	002e	bc26	0002	0013	002f	c800
    38	0014	000b	0015	0002	0000	002f	c800	0001	000a	002f	c800
    39	0015	000b	d82f	0001	0000	002f	c800	0002	00a0	002f	c800
    40	0016	000b	8831	0002	0000	002f	c800	0002	00a0	0031	d82d
    41	0017	000b	942c	0002	0000	0031	d82d	0002	00aa	002c	8833
    42	0018	000b	dc2c	0002	0000	002c	8833	0001	000a	002c	8833
    43	0019	000b	d82d	0001	0000	002c	8833	0002	000a	002d	942c
    44	001a	000b	8832	0002	0000	002d	942c	0002	0000	0032	1414
    45	001b	000b	0003	0002	0000	0032	1414	0002	ffff	0032	1414
    46	001c	000b	8832	0002	0000	0032	1414	0002	0f00	0032	1414
    47	001d	000b	942c	0002	0000	0032	1414	0002	0faa	002c	8833
    48	001e	000b	dc2c	0002	0000	002c	8833	0001	000a	002c	8833
    49	001f	000b	d82d	0001	0000	002c	8833	0002	000a	002d	942c
    50	0020	000b	8833	0002	0000	002d	942c	0002	0000	0033	0018
    51	0021	000b	0003	0002	0000	0033	0018	0002	ffff	0033	0018
    52	0022	000b	8833	0002	0000	0033	0018	0002	3000	0033	0018
    53	0023	000b	942c	0002	0000	0033	0018	0002	3faa	002c	8833
    54	0026	000b	bc26	0002	0000	002c	8833	0002	3faa	0026	8832
    55	0027	000b	d82d	0002	0000	0026	8832	0003	000a	002d	942c
    56	0028	000b	1414	0003	0000	002d	942c	0001	000a	002d	942c
    57	0029	000b	0018	0001	0000	002d	942c	0001	000a	002d	942c
bash-4.2$ cat -n trace_file.txt | tail -60
     1	PC  	BR  	IR  	TOS 	S[TOS]	EA  	MEM[EA]	TOS 	S[TOS]	EA  	MEM[EA]	
     2	
     3	000c	000b	0013	0000	EMPTY	0000	0000	0001	000a	0000	0000
     4	000d	000b	dc2d	0001	0000	0000	0000	0000	EMPTY	002d	942c
     5	000e	000b	d82d	0000	EMPTY	002d	942c	0001	000a	002d	942c
     6	000f	000b	b029	0001	0000	002d	942c	0002	0001	0029	d82d
     7	0010	000b	c424	0002	0000	0029	d82d	0001	000a	0024	8832
     8	0011	000b	8830	0001	0000	0024	8832	0001	000a	0030	d82f
     9	0012	000b	d834	0001	0000	0030	d82f	0002	000a	0034	0000
    10	0013	000b	dc2c	0002	0000	0034	0000	0001	000a	002c	8833
    11	0000	000b	c800	0001	0000	002c	8833	0002	0013	0000	0000
    12	0001	000b	d82d	0002	0000	0000	0000	0003	000a	002d	942c
    13	0004	000b	bc04	0003	0000	002d	942c	0003	000a	0004	0000
    14	0005	000b	000a	0003	0000	0004	0000	0003	0014	0004	0000
    15	0006	000b	d82e	0003	0000	0004	0000	0004	0001	002e	bc26
    16	0007	000b	b42b	0004	0000	002e	bc26	0005	0001	002b	0003
    17	0002	000b	c002	0005	0000	002b	0003	0004	0001	0002	0000
    18	0003	000b	942a	0004	0000	0002	0000	0004	0002	002a	8833
    19	0004	000b	dc2e	0004	0000	002a	8833	0003	0014	002e	bc26
    20	0005	000b	000a	0003	0000	002e	bc26	0003	0028	002e	bc26
    21	0006	000b	d82e	0003	0000	002e	bc26	0004	0002	002e	bc26
    22	0007	000b	b42b	0004	0000	002e	bc26	0005	0001	002b	0003
    23	0002	000b	c002	0005	0000	002b	0003	0004	0002	0002	0000
    24	0003	000b	942a	0004	0000	0002	0000	0004	0003	002a	8833
    25	0004	000b	dc2e	0004	0000	002a	8833	0003	0028	002e	bc26
    26	0005	000b	000a	0003	0000	002e	bc26	0003	0050	002e	bc26
    27	0006	000b	d82e	0003	0000	002e	bc26	0004	0003	002e	bc26
    28	0007	000b	b42b	0004	0000	002e	bc26	0005	0001	002b	0003
    29	0002	000b	c002	0005	0000	002b	0003	0004	0003	0002	0000
    30	0003	000b	942a	0004	0000	0002	0000	0004	0004	002a	8833
    31	0004	000b	dc2e	0004	0000	002a	8833	0003	0050	002e	bc26
    32	0005	000b	000a	0003	0000	002e	bc26	0003	00a0	002e	bc26
    33	0006	000b	d82e	0003	0000	002e	bc26	0004	0004	002e	bc26
    34	0007	000b	b42b	0004	0000	002e	bc26	0005	0000	002b	0003
    35	0008	000b	c002	0005	0000	002b	0003	0004	0004	0002	0000
    36	0009	000b	dc2e	0004	0000	0002	0000	0003	00a0	002e	bc26
    37	000a	000b	dc2f	0003	0000	002e	bc26	0002	0013	002f	c800
    38	0014	000b	0015	0002	0000	002f	c800	0001	000a	002f	c800
    39	0015	000b	d82f	0001	0000	002f	c800	0002	00a0	002f	c800
    40	0016	000b	8831	0002	0000	002f	c800	0002	00a0	0031	d82d
    41	0017	000b	942c	0002	0000	0031	d82d	0002	00aa	002c	8833
    42	0018	000b	dc2c	0002	0000	002c	8833	0001	000a	002c	8833
    43	0019	000b	d82d	0001	0000	002c	8833	0002	000a	002d	942c
    44	001a	000b	8832	0002	0000	002d	942c	0002	0000	0032	1414
    45	001b	000b	0003	0002	0000	0032	1414	0002	ffff	0032	1414
    46	001c	000b	8832	0002	0000	0032	1414	0002	0f00	0032	1414
    47	001d	000b	942c	0002	0000	0032	1414	0002	0faa	002c	8833
    48	001e	000b	dc2c	0002	0000	002c	8833	0001	000a	002c	8833
    49	001f	000b	d82d	0001	0000	002c	8833	0002	000a	002d	942c
    50	0020	000b	8833	0002	0000	002d	942c	0002	0000	0033	0018
    51	0021	000b	0003	0002	0000	0033	0018	0002	ffff	0033	0018
    52	0022	000b	8833	0002	0000	0033	0018	0002	3000	0033	0018
    53	0023	000b	942c	0002	0000	0033	0018	0002	3faa	002c	8833
    54	0026	000b	bc26	0002	0000	002c	8833	0002	3faa	0026	8832
    55	0027	000b	d82d	0002	0000	0026	8832	0003	000a	002d	942c
    56	0028	000b	1414	0003	0000	002d	942c	0001	000a	002d	942c
    57	0029	000b	0018	0001	0000	002d	942c	0001	000a	002d	942c
bash-4.2$ cat -n assm_my_job.txt 
     1	
     2	## MY JOB : FACTORIAL ##
     3		RD
     4		POP VAL
     5		CALL SWAP
     6		PUSH ANS
     7		WR
     8		HLT
     9	SWAP   :PUSH INDEX
    10		BR FIRST
    11	LOOP   :ADD ONE
    12		POP INDEX
    13	FIRST  :PUSH INDEX
    14		MUL
    15		PUSH INDEX
    16		CPL VAL
    17		BRT LOOP
    18		POP ANS
    19		RTN
    20			
    21			
    22	VAL	0000
    23	INDEX   0001
    24	ONE	0001
    25	ANS	0000
bash-4.2$ cat -n my_job.txt 
     1	01 00 00 17 1
     2	0013dc14c806d817
     3	00140018d815bc0a
     4	9416dc15d8150007
     5	d815b414c008DC15
     6	DC17001500000000
     7	000000010001bash-4.2$ 
bash-4.2$ java System3[K2 my_job.txt 
ENTER INPUT:
5
OUTPUT:120
bash-4.2$ cat -n output_file.txt 
     1	JOB ID :	1
     2	
     3	NORMAL EXECUTION
     4	OUTPUT:
     5	120
     6	
     7	
     8	CLOCK   (HEX):	00b9
     9	Run Time(DEC):	185
    10	ExecTime(DEC):	157
    11	I/O Time(DEC):	28
bash-4.2$ cat -n trace_file.txt |head -60
     1	PC  	BR  	IR  	TOS 	S[TOS]	EA  	MEM[EA]	TOS 	S[TOS]	EA  	MEM[EA]	
     2	
     3	0001	0000	0013	0000	EMPTY	0000	0013	0001	0005	0000	0013
     4	0002	0000	dc14	0001	0000	0000	0013	0000	EMPTY	0014	0005
     5	0006	0000	c806	0000	EMPTY	0014	0005	0001	0002	0006	d815
     6	0007	0000	d815	0001	0000	0006	d815	0002	0001	0015	0001
     7	000a	0000	bc0a	0002	0000	0015	0001	0002	0001	000a	d815
     8	000b	0000	d815	0002	0000	000a	d815	0003	0001	0015	0001
     9	000c	0000	0007	0003	0000	0015	0001	0002	0001	0015	0001
    10	000d	0000	d815	0002	0000	0015	0001	0003	0001	0015	0001
    11	000e	0000	b414	0003	0000	0015	0001	0004	0001	0014	0005
    12	0008	0000	c008	0004	0000	0014	0005	0003	0001	0008	9416
    13	0009	0000	9416	0003	0000	0008	9416	0003	0002	0016	0001
    14	000a	0000	dc15	0003	0000	0016	0001	0002	0001	0015	0002
    15	000b	0000	d815	0002	0000	0015	0002	0003	0002	0015	0002
    16	000c	0000	0007	0003	0000	0015	0002	0002	0002	0015	0002
    17	000d	0000	d815	0002	0000	0015	0002	0003	0002	0015	0002
    18	000e	0000	b414	0003	0000	0015	0002	0004	0001	0014	0005
    19	0008	0000	c008	0004	0000	0014	0005	0003	0002	0008	9416
    20	0009	0000	9416	0003	0000	0008	9416	0003	0003	0016	0001
    21	000a	0000	dc15	0003	0000	0016	0001	0002	0002	0015	0003
    22	000b	0000	d815	0002	0000	0015	0003	0003	0003	0015	0003
    23	000c	0000	0007	0003	0000	0015	0003	0002	0006	0015	0003
    24	000d	0000	d815	0002	0000	0015	0003	0003	0003	0015	0003
    25	000e	0000	b414	0003	0000	0015	0003	0004	0001	0014	0005
    26	0008	0000	c008	0004	0000	0014	0005	0003	0003	0008	9416
    27	0009	0000	9416	0003	0000	0008	9416	0003	0004	0016	0001
    28	000a	0000	dc15	0003	0000	0016	0001	0002	0006	0015	0004
    29	000b	0000	d815	0002	0000	0015	0004	0003	0004	0015	0004
    30	000c	0000	0007	0003	0000	0015	0004	0002	0018	0015	0004
    31	000d	0000	d815	0002	0000	0015	0004	0003	0004	0015	0004
    32	000e	0000	b414	0003	0000	0015	0004	0004	0001	0014	0005
    33	0008	0000	c008	0004	0000	0014	0005	0003	0004	0008	9416
    34	0009	0000	9416	0003	0000	0008	9416	0003	0005	0016	0001
    35	000a	0000	dc15	0003	0000	0016	0001	0002	0018	0015	0005
    36	000b	0000	d815	0002	0000	0015	0005	0003	0005	0015	0005
    37	000c	0000	0007	0003	0000	0015	0005	0002	0078	0015	0005
    38	000d	0000	d815	0002	0000	0015	0005	0003	0005	0015	0005
    39	000e	0000	b414	0003	0000	0015	0005	0004	0000	0014	0005
    40	000f	0000	c008	0004	0000	0014	0005	0003	0005	0008	9416
    41	0010	0000	dc15	0003	0000	0008	9416	0002	0078	0015	0005
    42	0011	0000	dc17	0002	0000	0015	0005	0001	0002	0017	0078
    43	0003	0000	0015	0001	0000	0017	0078	0000	EMPTY	0017	0078
    44	0004	0000	d817	0000	EMPTY	0017	0078	0001	0078	0017	0078
    45	0005	0000	0014	0001	0000	0017	0078	0000	EMPTY	0017	0078
    46	0006	0000	0018	0000	EMPTY	0017	0078	0000	EMPTY	0017	0078
bash-4.2$ cat -n assmcode/assm_ar_div_by_zero.txt 
     1	
     2	##TEST JOB ARITHEMATIC DIVIDE BY ZERO##
     3	RD
     4	RD
     5	DIV
     6	HLTbash-4.2$ 
bash-4.2$ cat -n tew[Kst_files/ass[K[K[Ktest_files[K[K[K[K[Kar_div_zero.txt 
     1	01 00 00 04 0
     2	0013001300080014bash-4.2$ 
bash-4.2$ cat -[K[K[K[K[Kjava System2 ./test_files/test_ar_div_zero.txt 
ENTER INPUT:
10
ENTER INPUT:
0
ERROR
bash-4.2$ cat -n output_file.txt 
     1	JOB ID :	1
     2	
     3	ERRORS :
     4	Error: ARITHEMATIC DIVIDE BY ZERO
     5	STACK TRACE
     6	Class Name :ErrorHandler.java Method Name :PrintStackTrace Line Number:117
     7	Class Name :ErrorHandler.java Method Name :throwError Line Number:105
     8	Class Name :CPU.java Method Name :runInstruction8 Line Number:308
     9	Class Name :CPU.java Method Name :splitInstruction Line Number:94
    10	Class Name :CPU.java Method Name :<init> Line Number:57
    11	Class Name :System2.java Method Name :main Line Number:41
    12	
    13	ABNORMAL EXECUTION
    14	
    15	MEMORY DUMP
    16	HEX 	Binary Value
    17	0013	0000000000010011
    18	0013	0000000000010011
    19	0008	0000000000001000
    20	0014	0000000000010100
    21	
    22	OUTPUT:
    23	
    24	
    25	CLOCK   (HEX):	0021
    26	Run Time(DEC):	33
    27	ExecTime(DEC):	5
    28	I/O Time(DEC):	28
bash-4.2$ cat -n assmcode/in[K[Kassm_invalid_opcode.txt 
     1	
     2	##TEST JOB INVALID OPCODE##
     3	An Invalid Opcode is given just a single value 001F is qiven.
     4	No Assembly Instruction for it.
bash-4.2$ cat -n test_files/test_invalid_opcode.txt 
     1	01 00 00 01 0
     2	001f
bash-4.2$ java System2.[K.[K ./test_files/test_input_out_of_range.txt [K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[Kvalid_opcode.txt 
ERROR
bash-4.2$ cat -n output_file.txt 
     1	JOB ID :	1
     2	
     3	ERRORS :
     4	Error : INVALID OPCODE
     5	STACK TRACE
     6	Class Name :ErrorHandler.java Method Name :PrintStackTrace Line Number:117
     7	Class Name :ErrorHandler.java Method Name :throwError Line Number:105
     8	Class Name :CPU.java Method Name :runInstruction8 Line Number:423
     9	Class Name :CPU.java Method Name :splitInstruction Line Number:94
    10	Class Name :CPU.java Method Name :<init> Line Number:57
    11	Class Name :System2.java Method Name :main Line Number:41
    12	
    13	ABNORMAL EXECUTION
    14	
    15	MEMORY DUMP
    16	HEX 	Binary Value
    17	001f	0000000000011111
    18	
    19	OUTPUT:
    20	
    21	
    22	CLOCK   (HEX):	0001
    23	Run Time(DEC):	1
    24	ExecTime(DEC):	1
    25	I/O Time(DEC):	0
bash-4.2$ cat -n assmcode/assm_stack_underflow.txt 
     1	
     2	##TEST JOB STACK UNDERFLOW##
     3	WR
     4	HLTbash-4.2$ 
bash-4.2$ cat -n ass[K[K[K[K test_files/test_stack_underflow.txt 
     1	01 00 00 01 0
     2	00140018bash-4.2$ 
bash-4.2$ cat -n output_file.txt [K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[Kjava System2.[K test_files/test_stack_underflow.txt 
ERROR
bash-4.2$ cat -n ot[Kutput_file.txt 
     1	JOB ID :	1
     2	
     3	ERRORS :
     4	STACK UNDERFLOW
     5	STACK TRACE
     6	Class Name :ErrorHandler.java Method Name :PrintStackTrace Line Number:117
     7	Class Name :ErrorHandler.java Method Name :throwError Line Number:105
     8	Class Name :Stack.java Method Name :pop Line Number:46
     9	Class Name :CPU.java Method Name :runInstruction8 Line Number:408
    10	Class Name :CPU.java Method Name :splitInstruction Line Number:94
    11	Class Name :CPU.java Method Name :<init> Line Number:57
    12	Class Name :System2.java Method Name :main Line Number:41
    13	
    14	ABNORMAL EXECUTION
    15	
    16	MEMORY DUMP
    17	HEX 	Binary Value
    18	0014	0000000000010100
    19	
    20	OUTPUT:
    21	
    22	
    23	CLOCK   (HEX):	0001
    24	Run Time(DEC):	1
    25	ExecTime(DEC):	1
    26	I/O Time(DEC):	0
bash-4.2$ ca[K[Kcat -n assmcode/assm_stack_overflow.txt 
     1	
     2	##TEST JOB STACK OVERFLOW##
     3	RD
     4	POP VAL
     5	PUSH VAL
     6	PUSH VAL
     7	PUSH VAL
     8	PUSH VAL
     9	PUSH VAL
    10	PUSH VAL
    11	PUSH VAL
    12	HLTbash-4.2$ 
bash-4.2$ cat -n test_files/test_stack_overflow.txt 
     1	01 00 00 0b 0
     2	0013dc15d815d815
     3	d815d815d815d815
     4	d815d8150018bash-4.2$ 
bash-4.2$ java System2.[K test_files/test_stack_overflow.txt 
ENTER INPUT:
10
ERROR
bash-4.2$ cat -n or[Kutput_file.txt 
     1	JOB ID :	1
     2	
     3	ERRORS :
     4	Error : STACK OVERFLOW
     5	STACK TRACE
     6	Class Name :ErrorHandler.java Method Name :PrintStackTrace Line Number:117
     7	Class Name :ErrorHandler.java Method Name :throwError Line Number:105
     8	Class Name :Stack.java Method Name :push Line Number:36
     9	Class Name :CPU.java Method Name :runInstruction16 Line Number:246
    10	Class Name :CPU.java Method Name :splitInstruction Line Number:87
    11	Class Name :CPU.java Method Name :<init> Line Number:57
    12	Class Name :System2.java Method Name :main Line Number:41
    13	
    14	ABNORMAL EXECUTION
    15	
    16	MEMORY DUMP
    17	HEX 	Binary Value
    18	0013	0000000000010011
    19	dc15	1101110000010101
    20	d815	1101100000010101
    21	d815	1101100000010101
    22	d815	1101100000010101
    23	d815	1101100000010101
    24	d815	1101100000010101
    25	d815	1101100000010101
    26	d815	1101100000010101
    27	d815	1101100000010101
    28	0018	0000000000011000
    29	
    30	OUTPUT:
    31	
    32	
    33	CLOCK   (HEX):	0030
    34	Run Time(DEC):	48
    35	ExecTime(DEC):	34
    36	I/O Time(DEC):	14
bash-4.2$ cat -n assmcode/b[Kassm_bad_trace_flag.txt 
     1	
     2	##TEST JOB BAD TRACE FLAG##
     3	RD
     4	WR
     5	HLTbash-4.2$ 
bash-4.2$ cat -n test_files/test_bad_trace_flag.txt 
     1	01 00 00 03 f
     2	001300140018bash-4.2$ 
bash-4.2$ java t[KSystem2.[K test_files/test_bad_trace_flag.txt 
ENTER INPUT:
15
OUTPUT:15
bash-4.2$ cat -n output_file.txt 
     1	JOB ID :	1
     2	
     3	WARNINGS
     4	Warning : Invalid CPU Trace Flag. Default 0 is taken
     5	
     6	NORMAL EXECUTION
     7	OUTPUT:
     8	15
     9	
    10	
    11	CLOCK   (HEX):	0021
    12	Run Time(DEC):	33
    13	ExecTime(DEC):	5
    14	I/O Time(DEC):	28
bash-4.2$ cat -n assmcode/assm_input_out_of_range.txt 
     1	
     2	##TEST JOB INPUT OUT OF RANGE##
     3		RD
     4		POP VAL
     5		PUSH VAL
     6		PUSH VAL
     7		MUL
     8	
     9	
    10	VAL   : 0000bash-4.2$ cat -n test_files/test_input_out_of_range.txt 
     1	01 00 00 07 0
     2	0013dc25d825d825
     3	000700140018bash-4.2$ 
bash-4.2$ java swe_report.txt [K[K[K[K[K[K[K[K[K[K[K[K[K[K[KSystem2.[K test_files/test_input_out_of_range.txt 
ENTER INPUT:
200
OUTPUT:0
bash-4.2$ cat -n output_file.txt 
     1	JOB ID :	1
     2	
     3	WARNINGS
     4	Warning : Invalid Input. Input Ranges between -32768 to 32767
     5	
     6	NORMAL EXECUTION
     7	OUTPUT:
     8	0
     9	
    10	
    11	CLOCK   (HEX):	002f
    12	Run Time(DEC):	47
    13	ExecTime(DEC):	19
    14	I/O Time(DEC):	28
bash-4.2$ cat -n assmcode/assm_inf_loop.txt 
     1	
     2	##TEST JOB INFINITE LOOP##
     3		RD
     4		POP INDEX
     5	LOOP   :PUSH INDEX
     6		CPE INDEX
     7		BRT LOOP
     8		HLTbash-4.2$ 
bash-4.2$ cat -n testF[Kf[K_files/test_inf_loop.txt 
     1	01 00 00 06 0
     2	0013dc05d805b805
     3	c0020018bash-4.2$ 
bash-4.2$ java St[Kystem2.[K test_files/test_inf_loop.txt 
ENTER INPUT:
1
WARNING : Possibility of Infinite Loop. Press 1 to exit
1
bash-4.2$ cat -n p[Koutputfile.t[K[K[K[K[K[K_file.txt 
     1	JOB ID :	1
     2	
     3	WARNINGS
     4	Warning : Possibility of Infinite Loop
     5	NORMAL EXECUTION
     6	OUTPUT:
     7	
     8	
     9	CLOCK   (HEX):	0054
    10	Run Time(DEC):	84
    11	ExecTime(DEC):	70
    12	I/O Time(DEC):	14
bash-4.2$ exit
exit

Script done on Tue 25 Feb 2014 02:25:22 PM CST
